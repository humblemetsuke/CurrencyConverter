from collections import defaultdict
from pathlib import Path


def get_latest_flake8_report(output_dir="reports", base_name="flake8-report"):

    report_path = Path(output_dir)
    # Use glob to match files like flake8-report_*.txt
    # The script for generating flake8 reports adds timestamps to the name.
    files = list(report_path.glob(f"{base_name}_*.txt"))
    if not files:
        print(f"No flake8 report files found in {output_dir}")
        return None
    # Sort files according to time of modification (descending order).
    files.sort(key=lambda f: f.stat().st_mtime, reverse=True)
    return files[0]


def summarise_flake8_report(file_path):
    """Creates a dictionary called error_counts, where each key
    will be a specific error code generated by flake8. The value of each
    key will represent the number of incidences of that specific error.
    We are using defaultdict as it will a default value to avoid KeyErrors.
    This is intended as code hygiene, and int will set the default value to 0.
    """
    error_counts = defaultdict(int)
    file_errors = defaultdict(list)
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f: # iterates through every line in the file.
            # line.strip() removes leading and trailing whitespaces.
            # the conditional statement is to skip any empty lines."""
            line = line.strip()
            if not line:
                continue
            try:
                # Attempts to split the line by colons, expecting the format:
                # filename:line_number:column_number: error_code message
                # if there is less than 4 parts, it's not valid, ergo, skip!
                parts = line.split(':')
                if len(parts) < 4:
                    continue
                filename = parts[0].strip() # first part of the line
                code = parts[3].strip().split()[0] # code can be parsed from
                # final line


                error_counts[code] += 1 # once error is found, update dictionary
                # by value of 1
                file_errors[filename].append(code)
                # Adds this error code to the
                # list of codes for the corresponding filename.

            # If something goes wrong while parsing a line,
            # it prints the line and the exception.
            # This avoids crashing on unexpected formats.
            except Exception as e:
                print(f"Failed to parse the line: {line}")
                print(e)

    # Section heading for the error report for readability.
    print("\nðŸ“Œ Error Summary by Code:")

    """Loops through the error codes sorted by frequency, descending.
    error_counts.items() gives all key and value pairs
    in the error_counts dictionary.
    sorted(..., key=lambda x: -x[1]) sorts the (code, count) in descending order
    [1] refers to the 2nd item in each pair, which is the count.
    using -x[1] reverses the sort, so the largest numbers come first."""

    for code, count in sorted(error_counts.items(), key=lambda x: -x[1]):
        # Prints each code and how many times it appeared.
        print(f"{code}: {count} occurrences")

    print("\nðŸ“ Top Files with Most Errors:")
    """len(x[1]) gives the total number of issues within the file
    -len(x[1]) inverts this, into descending order
    meaning the most issues appear."""
    sorted_files = sorted(file_errors.items(), key=lambda x: -len(x[1]))
    for file, codes in sorted_files[:10]:  # Top 10 files
        print(f"{file}: {len(codes)} issues")


if __name__ == "__main__":
    latest_report = get_latest_flake8_report()
    if latest_report:
        summarise_flake8_report()
    summarise_flake8_report("reports/flake8_report.txt")
